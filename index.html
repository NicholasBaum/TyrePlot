<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tyre Plots Imola</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <script src="https://cdn.plot.ly/plotly-2.24.2.min.js" charset="utf-8"></script>
</head>
<!-- https://nicholasbaum.github.io/TyrePlot/ -->

<body>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz"
        crossorigin="anonymous"></script>

    <div class="container">
        <div class="mb-3">
            <select class="form-select" id="cbCar"></select>
            <select class="form-select" id="cbRun"></select>
            <select class="form-select" id="cbFile"></select>
        </div>
        <div id="channelSelection"></div>
        <div id="plotElement"></div>
    </div>

    <script>
        let files;
        let currentFile;
        initialize();


        // functions

        function initialize() {
            getFileDescriptions()
                .then(data => {
                    files = data;
                    populateSelections()
                });
        }

        function populateSelections() {
            const cbCar = document.getElementById('cbCar');
            const cbRun = document.getElementById('cbRun');
            const cbFile = document.getElementById('cbFile');

            cbCar.addEventListener('change', event => {
                fillComboBox(cbRun, files.events.imola_2023[event.target.value]);
            })
            cbRun.addEventListener('change', event => {
                fillComboBox(cbFile, files.events.imola_2023[cbCar.value][event.target.value]);
            })
            cbFile.addEventListener('change', event => {
                const file = files.events.imola_2023[cbCar.value][cbRun.value][event.target.value];
                if (file.channels !== null) {
                    currentFile = file;
                    createChannelSelectionUI();
                }
                else {
                    getCsv(file.url).then(x => {
                        file.channels = x;
                        currentFile = file;
                        createChannelSelectionUI();
                    })
                }
            })

            fillComboBox(cbCar, files.events.imola_2023);
        }

        function createChannelSelectionUI() {
            const el = document.getElementById('channelSelection');
            el.innerHTML = '';
            const ul = document.createElement('ul');
            console.log(currentFile);
            Object.keys(currentFile.channels).forEach(key => {
                const li = document.createElement('li');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = key;
                checkbox.value = key;
                checkbox.addEventListener('change', function () {
                    if (this.checked) {
                        render(currentFile.channels[this.value])
                    } else {
                        console.log('Checkbox unchecked:', this.value);
                    }
                });
                const label = document.createElement(key);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(key));
                li.appendChild(label);
                ul.appendChild(li);
            });

            el.appendChild(ul);
        }

        function fillComboBox(comboBox, json) {
            comboBox.innerHTML = '';
            Object.keys(json).forEach(key => {
                const opt = document.createElement('option');
                opt.text = key;
                opt.value = key;
                comboBox.appendChild(opt);
            });
            // trigger a refreh
            comboBox.dispatchEvent(new Event("change"));
        }

        function render(channel) {
            Plotly.newPlot("plotElement", /* JSON object */ {
                "data": [{ "y": channel }],
                "layout": { "width": 600, "height": 400 }
            })
        }

        function getCsv(url) {
            return fetch(url)
                .then(x => x.json())
                .then(x => atob(x.content))
                .then(csv => parseCSV(csv))
                .catch(err => console.log(err));
        }

        function parseCSV(csvData) {
            const lines = csvData.split('\n');
            const headers = lines[0].split(',');
            const data = [];

            for (let j = 0; j < headers.length - 1; j++) {
                data[headers[j]] = [];
            }

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                for (let j = 0; j < values.length - 1; j++) {
                    if (j == 0) {
                        data[headers[j]][i - 1] = values[j];
                        continue;
                    }
                    data[headers[j]][i - 1] = parseFloat(values[j]);
                }
            }
            return data;
        }

        function getFileDescriptions() {
            const url = "https://api.github.com/repos/NicholasBaum/TyrePlot/git/trees/gh-pages?recursive=1";

            return fetch(url)
                .then(response => response.json())
                .then(data => {
                    // Filter the response to include only CSV files
                    const csvFiles = data.tree.filter(file => file.path.endsWith('.csv'));

                    // Function to create nested JSON
                    const createNestedJson = (path, value) => {
                        const keys = path.split('/').slice(1); // Exclude the first level
                        const filename = keys.pop(); // Remove the filename from the path
                        let currentLevel = nestedJson;

                        // Create nested directories if they don't exist
                        keys.forEach(key => {
                            if (!currentLevel[key]) {
                                currentLevel[key] = {};
                            }
                            currentLevel = currentLevel[key];
                        });

                        currentLevel[filename] = { 'name': filename, 'url': value, 'channels': null }
                    };

                    // Create nested JSON structure for CSV files
                    const nestedJson = {};
                    csvFiles.forEach(file => {
                        const { path, url } = file;
                        createNestedJson(path, url);
                    });

                    // Print the resulting nested JSON
                    //console.log(JSON.stringify(nestedJson, null, 4));
                    return nestedJson;
                })
                .catch(error => console.error("Error:", error));

        }



    </script>
</body>

</html>